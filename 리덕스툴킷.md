## 1단계 : 아주 간단하게 정의하고 생성하고 가져오고 업데이트

리덕스란
전역 상태 관리 라이브러리


## Three Principles of Redux

https://www.frontoverflow.com/document/1/%EC%B2%98%EC%9D%8C%20%EB%A7%8C%EB%82%9C%20%EB%A6%AC%EB%8D%95%EC%8A%A4%20(Redux)/chapter/2/Redux%20%EC%86%8C%EA%B0%9C/section/6/Three%20Principles%20of%20Redux

<span style="color:#0070c0">Single source of truth</span>
**단일 진실의 원천(Single source of truth)**: 애플리케이션의 모든 상태는 하나의 객체 트리(스토어) 내에 저장(컨텍스트는 단일 진실의 원천이 아님.)
<span style="color:#0070c0">State is read-only</span>
**상태는 읽기 전용(Read-only)**: 상태를 변경할 수 있는 유일한 방법은 액션(action)이라는 객체를 보내는 것
 사전에 미리 정의해둔 어떤 상황이 발생했을 경우에 사전에 정해진대로만 상태를 변경

<span style="color:#0070c0">Changes are made with pure functions</span>
**순수 함수로서의 리듀서(Reducers are pure functions)**: 액션을 받아 이전 상태를 다음 상태로 변환
사이드 이펙트를 발생시키지 마라.

리덕스 간단 예시 : setUser

정의하기
생성하기
가져오기
업데이트하기

4단계로 나누어서 이해하자.



<span style="color:#ffc000">정의하기 </span>
<span style="color:#fb4141">액션 타입</span>을 정의
<span style="color:#fb4141">액션 생성자</span>를 정의
<span style="color:#fb4141">초기상태</span>와 <span style="color:#fb4141">리듀서</span>를 정의
<span style="color:#ffc000">생성하기</span>
리듀서를 바탕으로(인자로) 스토어를 생성한다. 스토어는 이때 상태들을 담은 껍데기 객체이다.
<span style="color:#ffc000">가져오기</span>
컴포넌트에서 스토어에서 값을 가져와서 사용한다
<span style="color:#ffc000">업데이트하기</span>
컴포넌트에서 클릭하면(무언가를 하면) 스토어의 값을 업데이트한다.
### 1. 액션 타입 및 액션 생성자 정의
액션 타입은 상태 업데이트를 위한 액션의 유형을 정의
액션 생성자는 액션 객체를 만들어 반환하는 함수
```js
// actions.js

// 액션 타입 정의
export const SET_USER = 'SET_USER';

// 액션 생성자
export function setUser(user) {
  return {
    type: SET_USER,
    payload: user
  };
}

```
### 2. 리듀서 정의
리듀서는 액션 타입에 따라 상태를 변경하는 로직
이전 상태와 액션을 받아 새 상태를 반환
```js
// reducer.js
import { SET_USER } from './actions';

const initialState = {
  user: {
    username: '',
    email: ''
  }
};

function userReducer(state = initialState, action) {
  switch (action.type) {
    case SET_USER:
    //복사 + 업데이트
      return {
        ...state,
        user: action.payload
      };
      
    default:
      return state;
  }
}

export default userReducer;


```
### 3. 스토어 생성
리듀서를 사용하여 Redux 스토어를 생성
스토어는 애플리케이션의 상태를 관리
```js
// store.js
import { createStore } from 'redux';
import userReducer from './reducer';

const store = createStore(userReducer);

export default store;

```
### 4. 스토어 사용/업데이트

스토어에 액션을 발송하면 리듀서가 호출되어 상태가 업데이트

```js
// index.js
import store from './store';
import { setUser } from './actions';

// 초기 상태 출력
console.log(store.getState());//{ user: { username: '', email: '' } }

// 액션 발송
store.dispatch(setUser({ username: '현준', email: 'hyunjun@example.com' }));

// 업데이트된 상태 출력
console.log(store.getState());// { user: { username: '현준', email: 'hyunjun@example.com' } }


```

스토어는 웹 페이지의 생명 주기와 일치하다. 웹 페이지 로드 될 때 생성, 페이지 종료 될 때 사라짐. 새로고침하면 스토어 초기화.
로그인시 사용자 정보와 토큰을 스토어에 저장
로그아웃 or 세션 만료시 스토어에서 제거


dispatch는 액션객체로 스토어에게 연락하는 거라고 볼 수 있어. "야 너 이름 현준으로 바꿔" 이렇게
dispatch는 액션생성자함수를 인자로 받아


## 2단계 : 편하게 가져오기 - connect, store.subscribe,useSelector
```js

// UserProfile.js
import React, { useState, useEffect } from 'react';
import store from './store'; // 스토어 가져오기

function UserProfile() {
  // 스토어의 초기 상태를 로컬 상태로 설정
  const user = store.getState().user;

  return (
    <div>
      <h1>User Profile</h1>
      <p><strong>Username:</strong> {user.username}</p>
      <p><strong>Email:</strong> {user.email}</p>
    </div>
  );
}

export default UserProfile;

```

리듀서를 이해했다.
user객체를 스토어에 저장했었음
그러면 회원정보보기버튼을 클릭했을때 스토어에서 가져와야함. 가져왔어.
그런데 이 코드는 문제가 있음 뭐냐면,
컴포넌트들이 모여서 하나의 페이지를 구성해.  하나의 페이지가 로드되고 종료될때동안 store는 유지됨
스토어를 만약에 이 페이지에서 store를 바꿨어. 그래도 얘는 안바뀐다. 스토어의 상태가 바뀔 때마다 자동으로 리렌더링 되도록 하지 않았다.

즉, 컴포넌트와 리덕스를 연결(구독)을 안했어

#### <span style="color:#ffc000">store.subscribe로 컴포넌트와 리덕스를 연결</span>
useState를 이용했고 store.subscribe(콜백함수)로 리스너를 생성시켰다. onClick같은 리스너를 생성시켰음.
store상태가 바뀔때마다 콜백함수가 실행된다. 호출하면 리스너 해제된다.
- store.subscribe는 Redux 스토어의 기본 API
- 스토어의 상태 변경을 감지 후 콜백 함수를 실행

이건 컴포넌트에서 직접 스토어를 구독하려고 시도하는건데 절대로 이렇게 하지 말라고 한다. 왜냐하면 컴포넌트가 스토어 자체를 구독하게 되면 안된다.. 스토어는 매우 거대한거고 공용공간인데, 스토어가 변할때마다 쓸데없이 변화를 감지하게 된다. 컴포넌트를 렌더링할때만 스토어 상태변화가 있는지 확인하면 된다...
```



```
```js
// UserProfile.js
import React, { useState, useEffect } from 'react';
import store from './store'; // 스토어 가져오기

function UserProfile() {
  // 스토어의 초기 상태를 로컬 상태로 설정
  const [user, setUser] = useState(store.getState().user);

  useEffect(() => {
    // 스토어 구독하여 상태 변화 감지
    const unsubscribe = store.subscribe(() => {
      setUser(store.getState().user); // 상태가 변할 때마다 로컬 상태 업데이트
    });

    // 컴포넌트 언마운트 시 구독 해제
    return () => {
      unsubscribe();
    };
  }, []);

  return (
    <div>
      <h1>User Profile</h1>
      <p><strong>Username:</strong> {user.username}</p>
      <p><strong>Email:</strong> {user.email}</p>
    </div>
  );
}

export default UserProfile;

```

#### <span style="color:#ffc000">connect함수로 연결(훅이 등장하기 전 많이 사용)</span>
```js
// src/components/App.js
import React from 'react';
import { connect } from 'react-redux';

const App = ({ isAuthenticated, user }) => {
  return (
    <div>
      {isAuthenticated ? (
        <div>
          <h1>환영합니다, {user.username}!</h1>
          {/* 로그인 후 보여줄 컴포넌트 */}
        </div>
      ) : (
        <div>
          <h1>로그인이 필요합니다.</h1>
          {/* 로그인 폼 또는 로그인 버튼 */}
        </div>
      )}
    </div>
  );
};

const mapStateToProps = (state) => ({
  isAuthenticated: state.auth.isAuthenticated,
  user: state.auth.user,
});

export default connect(mapStateToProps)(App);
```
고차함수
```js
function createCounter(initialValue) {
  let value = initialValue;
  return function(increment) {
    value += increment;
    return value;
  };
}

console.log(createCounter(10)(5));  // 초기 값 10에 5를 더해 출력: 15
```

#### <span style="color:#ffc000">useSelector로 연결</span>
Redux 스토어의 상태를 선택(select)하여 사용
컴포넌트는 `필요한 부분(상태)만을 선택`하여 구독
`해당 상태가 변경될 때마다 컴포넌트가 재렌더링`
```js
// UserProfile.js
import React from 'react';
import { useSelector } from 'react-redux';

function UserProfile() {
  // 스토어의 state에서 user 상태를 선택
  const user = useSelector(state => state.user);

  return (
    <div>
      <h1>User Profile</h1>
      <p><strong>Username:</strong> {user.username}</p>
      <p><strong>Email:</strong> {user.email}</p>
    </div>
  );
}
export default UserProfile;
```

```js
// App.js
import React from 'react';
import UserProfile from './UserProfile';
import { Provider } from 'react-redux';
import store from './store';

function App() {
  return (
    <Provider store={store}>
      <div>
        <h1>Welcome to the Redux Example</h1>
        <UserProfile />
      </div>
    </Provider>
  );
}
export default App;
```


## 3단계 : 편하게 업데이트 - useDispatcher

대스패치가 호출되면 리듀서함수가 호출된다. 리듀서함수의 액션핸들러함수는 상태와 액션을 인자로 받았었다.
상태는 스토어의 상태이고, 액션은 디스패치가 전달해준 액션이다.

```js
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './counterActions';

const Counter = () => {
  const count = useSelector((state) => state.counter.count);
  const dispatch = useDispatch();
  const handleIncrement = () => {
    dispatch(increment());
  };

  const handleDecrement = () => {
    dispatch(decrement());
  };

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={handleIncrement}>Increment</button>
      <button onClick={handleDecrement}>Decrement</button>
    </div>
  );
};

export default Counter;
```


## 4단계 : 편하게 정의하고 생성하기
<span style="color:#ffc000">리덕스 툴킷</span>
약속 1 : 액션타입명=슬라이스명/액션생성자명
약속 2 : 스토어는 여러개의 슬라이스로 구성
약속 3 : 슬라이스당 하나의 리듀서 함수가 있다. 
약속 4 : 리듀서 함수는 여러개의 액션핸들러와 초기상태로 이루어져 있다.핸들러메서드 1개는  1개의 액션타입으로 매핑되어있다. 
약속 5 : 슬라이스명과 액션타입명, 실행할 리듀서함수만 정해주면 액션 생성자 함수가 만들어진다.
약속 6 : 액션 생성자 함수와 리듀서를 내보내야 한다.

reducers : {
	액션생성자명 : 액션핸들러함수 내부 로직,
	액션생성자명 : 액션핸들러함수 내부 로직,
	...
}
```js
//액션 타입, 액션 생성자, 초기 상태와 리듀서 정의 (counterSlice.js)
// counterSlice.js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',//슬라이스 명
  initialState: {//초기상태
    value: 0,
  },
  reducers: {
  //핸들러메서드
  //슬라이스 - 하나의 리듀서함수 : 액션타입 
  //counter/increment
  //여기 꼭 action이 있어야하는건 아니다. 여기 action을 인자로 안적어도 된다. 하지만 내부적으로 리듀서함수는 action을 인자로 갖는다. 왜냐면 액션타입은 확인해야하기 때문이다. (state, action) => {state.value += action.payload;}는 액션핸들러함수 내부로직일 뿐이라고 볼 수 있다. 액션생성자명: 액션핸들러함수내부로직
    increment: (state, action) => {
      state.value += action.payload;
    },
    decrement: (state, action) => {
      state.value -= action.payload;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;//액션생성자 담긴 곳
//
export default counterSlice.reducer;
```

```js
// store.js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,//슬라이스명 : 리듀서명,
  },
});

export default store;
```

내부적으로 생성되는 액션 생성자 함수
```js
// 내부적으로 생성되는 액션 생성자 함수
function increment(payload) {
  return {
    type: 'counter/increment',
    payload,
  };
}

function decrement(payload) {
  return {
    type: 'counter/decrement',
    payload,
  };
}
```


컴포넌트 (가져오기 업데이트하기)
```js
// CounterComponent.js
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './counterSlice';

function CounterComponent() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();
  const [amount, setAmount] = useState(1);

  return (
    <div>
      <h1>Counter: {count}</h1>
      <input
        type="number"
        value={amount}
        onChange={(e) => setAmount(parseInt(e.target.value))}
      />
      <button onClick={() => dispatch(increment(amount))}>Increment</button>
      <button onClick={() => dispatch(decrement(amount))}>Decrement</button>
    </div>
  );
}

export default CounterComponent;

```






## 5단계 : middleWare
```js
// src/features/auth/authSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

export const checkSession = createAsyncThunk(
  'auth/checkSession',
  async () => {
    const response = await axios.get('/api/check-session');
    return response.data;
  }
);

const authSlice = createSlice({
  name: 'auth',
  initialState: {
    isAuthenticated: false,
    user: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(checkSession.fulfilled, (state, action) => {
        state.isAuthenticated = action.payload.isAuthenticated;
        state.user = action.payload.user;
      });
  },
});

export default authSlice.reducer;
```
```js
// src/store.js
import { configureStore } from '@reduxjs/toolkit';
import authReducer from './features/auth/authSlice';

const store = configureStore({
  reducer: {
    auth: authReducer,
  },
});

export default store;
```

```js
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import store from './store';
import { checkSession } from './features/auth/authSlice';
import App from './App';

store.dispatch(checkSession());

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
```


```js
// src/components/App.js
import React from 'react';
import { useSelector } from 'react-redux';

const App = () => {
  const { isAuthenticated, user } = useSelector((state) => state.auth);

  return (
    <div>
      {isAuthenticated ? (
        <div>
          <h1>환영합니다, {user.username}!</h1>
          {/* 로그인 후 보여줄 컴포넌트 */}
        </div>
      ) : (
        <div>
          <h1>로그인이 필요합니다.</h1>
          {/* 로그인 폼 또는 로그인 버튼 */}
        </div>
      )}
    </div>
  );
};

export default App;
```


| a   | b   | c   |
| --- | --- | --- |
| d   | e   | f   |
| g   | h   | i   |
